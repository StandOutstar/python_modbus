import struct
SlaveIdDict = {0x01: '下位机'}
FunCodeDict = {0x03: '读取', 0x06: '设置', 0x10: '设置'}
RegisterBlockDict = {0x00: '状态监控区', 0x01: '状态监控区', 0x10: '分解动作区', 0x11: '分解动作区', 0x20: '连贯动作区', 0x30: '系统参数区'}
StateBlockDict = {
    0x0000: '脖子前后向电机状态', 0x0001: '脖子前后向电机角度',
    0x0002: '脖子左右向电机状态', 0x0003: '脖子左右向电机角度',
    0x0004: '左肩膀前后向电机状态', 0x0005: '左肩膀前后向电机角度',
    0x0006: '右肩膀前后向电机状态', 0x0007: '右肩膀前后向电机角度',
    0x0008: '左肩膀左右向电机状态', 0x0009: '左肩膀左右向电机角度',
    0x000A: '右肩膀左右向电机状态', 0x000B: '右肩膀左右向电机角度',
    0x000C: '左臂转向电机状态', 0x000D: '左臂转向电机角度',
    0x000E: '右臂转向电机状态', 0x000F: '右臂转向电机角度',
    0x0010: '左肘前后向电机状态', 0x0011: '左肘前后向电机角度',
    0x0012: '右肘前后向电机状态', 0x0013: '右肘前后向电机角度',
    0x0014: '左前臂转向电机状态', 0x0015: '左前臂转向电机角度',
    0x0016: '右前臂转向电机状态', 0x0017: '右前臂转向电机角度',
    0x0018: '左腕前后向电机状态', 0x0019: '左腕前后向电机角度',
    0x001A: '右腕前后向电机状态', 0x001B: '右腕前后向电机角度',
    0x001C: '左腕左右向电机状态', 0x001D: '左腕左右向电机角度',
    0x001E: '右腕左右向电机状态', 0x001F: '右腕左右向电机角度',
    0x0020: '左大腿根左右向电机状态', 0x0021: '左大腿根左右向电机角度',
    0x0022: '右大腿根左右向电机状态', 0x0023: '右大腿根左右向电机角度',
    0x0024: '左大腿根前后向电机状态', 0x0025: '左大腿根前后向电机角度',
    0x0026: '右大腿根前后向电机状态', 0x0027: '右大腿根前后向电机角度',
    0x0028: '左膝盖前后向电机状态', 0x0029: '左膝盖前后向电机角度',
    0x002A: '右膝盖前后向电机状态', 0x002B: '右膝盖前后向电机角度',
    0x002C: '左脚腕前后向电机状态', 0x002D: '左脚腕前后向电机角度',
    0x002E: '右脚腕前后向电机状态', 0x002F: '右脚腕前后向电机角度',
    0x0030: '左脚腕左右向电机状态', 0x0031: '左脚腕左右向电机角度',
    0x0032: '右脚腕左右向电机状态', 0x0033: '右脚腕左右向电机角度',
    0x0034: '左大腿转向电机状态', 0x0035: '左大腿转向电机角度',
    0x0036: '右大腿转向电机状态', 0x0037: '右大腿转向电机角度',
    0x0038: '左睛状态', 0x0039: '左睛角度/RGB',
    0x003A: '右睛状态', 0x003B: '右睛角度/RGB',
    0x003C: '腰部电机状态', 0x003D: '腰部电机角度',
    0x003E: '下巴电机状态', 0x003F: '下巴电机角度',
    0x0100: '软件版本号', 0x0101: '硬件版本号',
    0x0102: '硬件序列号低位', 0x0103: '硬件序列号高位',
    0x0104: '红外探头状态', 0x0105: '超声波状态',
    0x0106: '下位机状态', 0x0107: '左手感应',
    0x0108: '右手感应', 0x0109: '头部触摸',
    0x010A: '惯性单元X轴角度', 0x010B: '惯性单元Y轴角度',
    0x010C: '惯性单元Z轴角度', 0x010D: '惯性单元X轴加速度',
    0x010E: '惯性单元Y轴加速度', 0x010F: '惯性单元Z轴加速度',
    0x0110: 'X轴角速度', 0x0111: 'Y轴角速度',
    0x0112: 'Z轴角速度', 0x0113: 'X轴磁场',
    0x0114: 'Y轴磁场', 0x0115: 'Z轴磁场',
    0x0116: '姿态识别', 0x0117: '系列动作运行状态',
    0x0118: '最大存储容量', 0x0119: '剩余文件数量',
    0x011A: '当前可用文件号', 0x011B: '当前可用记录号',
    0x011C: '已保存表情数量', 0x011D: '已保存系列动作数量',
    0x011E: '运行模式', 0x011F: '随机数低位',
    0x0120: '随机数高位', 0x0121: '二维码01',
    0x0122: '二维码02', 0x0123: '二维码03',
    0x0124: '二维码04', 0x0125: '二维码05',
    0x0126: '二维码06',
    0x1000: '脖子前后向电机状态', 0x1001: '脖子前后向电机角度',
    0x1002: '脖子左右向电机状态', 0x1003: '脖子左右向电机角度',
    0x1004: '左肩膀前后向电机状态', 0x1005: '左肩膀前后向电机角度',
    0x1006: '右肩膀前后向电机状态', 0x1007: '右肩膀前后向电机角度',
    0x1008: '左肩膀左右向电机状态', 0x1009: '左肩膀左右向电机角度',
    0x100A: '右肩膀左右向电机状态', 0x100B: '右肩膀左右向电机角度',
    0x100C: '左臂转向电机状态', 0x100D: '左臂转向电机角度',
    0x100E: '右臂转向电机状态', 0x100F: '右臂转向电机角度',
    0x1010: '左肘前后向电机状态', 0x1011: '左肘前后向电机角度',
    0x1012: '右肘前后向电机状态', 0x1013: '右肘前后向电机角度',
    0x1014: '左前臂转向电机状态', 0x1015: '左前臂转向电机角度',
    0x1016: '右前臂转向电机状态', 0x1017: '右前臂转向电机角度',
    0x1018: '左腕前后向电机状态', 0x1019: '左腕前后向电机角度',
    0x101A: '右腕前后向电机状态', 0x101B: '右腕前后向电机角度',
    0x101C: '左腕左右向电机状态', 0x101D: '左腕左右向电机角度',
    0x101E: '右腕左右向电机状态', 0x101F: '右腕左右向电机角度',
    0x1020: '左大腿根左右向电机状态', 0x1021: '左大腿根左右向电机角度',
    0x1022: '右大腿根左右向电机状态', 0x1023: '右大腿根左右向电机角度',
    0x1024: '左大腿根前后向电机状态', 0x1025: '左大腿根前后向电机角度',
    0x1026: '右大腿根前后向电机状态', 0x1027: '右大腿根前后向电机角度',
    0x1028: '左膝盖前后向电机状态', 0x1029: '左膝盖前后向电机角度',
    0x102A: '右膝盖前后向电机状态', 0x102B: '右膝盖前后向电机角度',
    0x102C: '左脚腕前后向电机状态', 0x102D: '左脚腕前后向电机角度',
    0x102E: '右脚腕前后向电机状态', 0x102F: '右脚腕前后向电机角度',
    0x1030: '左脚腕左右向电机状态', 0x1031: '左脚腕左右向电机角度',
    0x1032: '右脚腕左右向电机状态', 0x1033: '右脚腕左右向电机角度',
    0x1034: '左大腿转向电机状态', 0x1035: '左大腿转向电机角度',
    0x1036: '右大腿转向电机状态', 0x1037: '右大腿转向电机角度',
    0x1038: '左睛状态', 0x1039: '左睛角度/RGB',
    0x103A: '右睛状态', 0x103B: '右睛角度/RGB',
    0x103C: '腰部电机状态', 0x103D: '腰部电机角度',
    0x103E: '下巴电机状态', 0x103F: '下巴电机角度',
    0x1100: '左耳部LED_01', 0x1101: '左耳部LED_02',
    0x1102: '右耳部LED_01', 0x1103: '右耳部LED_02',
    0x1104: '眼睑部件',
    0x2000: '并发动作控制字',
    0x2001: 'A动作编号', 0x2002: 'A动作参数',
    0x2003: 'B动作编号', 0x2004: 'B动作参数',
    0x2005: 'C动作编号', 0x2006: 'C动作参数',
    0x200F: 'LED控制字',
    0x2010: '效果编号',  0x2011: '效果参数1',
    0x2012: '效果参数2', 0x2013: '效果参数3',
    0x2014: '表情控制字',
    0x2015: '表情编号',  0x2016: '表情参数1',
    0x2017: '表情参数2', 0x2018: '表情参数3',
    0x3000: '电机复位',     0x3001: '电源管理',
    0x3002: '耳部LED开关',  0x3003: '固件升级请求',
    0x3004: '充电开关',     0x3005: '超声波安全距离',
    0x3006: '红外安全距离', 0x3007: '保存数据请求',
    0x3008: '控制密码开关', 0x3009: '密码高位',
    0x300A: '密码低位',     0x300B: '禁用外设电量阈值',
    0x300C: '主板打断状态', 0x300D: '波特率_01',
    0x300E: '波特率_02',    0x300F: '屏幕参数'
}


def parse_modbus_request(requestpdu):
    modbus_request = requestpdu[1]
    (slaveid, funcode) = struct.unpack('>BB', modbus_request[0:2])  # 拆包结果是个tuple
    (regaddress, ) = struct.unpack('>H', modbus_request[2:4])  # 拆包结果是个tuple
    (blockaddress, ) = struct.unpack('>B', modbus_request[2:3])  # 拆包结果是个tuple
    # print(modbus_request)
    # print(hex(regaddress))
    print("发给", SlaveIdDict[slaveid], FunCodeDict[funcode], RegisterBlockDict[blockaddress], "起始地址:", hex(regaddress), "起始位置:", StateBlockDict[regaddress])

    if funcode == 0x03:
        (quantity, ) = struct.unpack('>H', modbus_request[4:6])
        print("长度:", quantity)
    elif funcode == 0x06:
        (dataa, ) = struct.unpack('>H', modbus_request[4:6])
        print("数据:", hex(dataa))
    elif funcode == 0x10:
        (quantity,) = struct.unpack('>H', modbus_request[4:6])
        (bytenum, ) = struct.unpack('>B', modbus_request[6:7])
        # print(type(bytenum))
        # bytenumm = bytenum + 7
        # print(bytenumm)
        # 从modbus_tk的原文件获取方法
        data = []
        count = 0
        for i in range(quantity):
            count += 1
            fmt = "H"
            data.append(struct.unpack(">" + fmt, modbus_request[7 + 2 * i:9 + 2 * i])[0])
        print("长度:", quantity, "字节数:", bytenum, ' ', end="")
        print("数据:", " ".join(hex(i) for i in data))
